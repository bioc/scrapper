% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adt_quality_control.R
\name{adt_quality_control}
\alias{adt_quality_control}
\alias{computeAdtQcMetrics}
\alias{suggestAdtQcThresholds}
\alias{filterAdtQcMetrics}
\title{Quality control for ADT count data}
\usage{
computeAdtQcMetrics(x, subsets, num.threads = 1)

suggestAdtQcThresholds(
  metrics,
  block = NULL,
  min.detected.drop = 0.1,
  num.mads = 3
)

filterAdtQcMetrics(thresholds, metrics, block = NULL)
}
\arguments{
\item{x}{A matrix-like object where rows are ADTs and columns are cells.
Values are expected to be counts.}

\item{subsets}{List of vectors specifying tag subsets of interest, typically control tags like IgGs.
Each vector may be logical (whether to keep each row), integer (row indices) or character (row names).}

\item{num.threads}{Integer scalar specifying the number of threads to use.}

\item{metrics}{List with the same structure as produced by \code{computeAdtQcMetrics}.}

\item{block}{Factor specifying the block of origin (e.g., batch, sample) for each cell in \code{metrics}.
Alternatively \code{NULL} if all cells are from the same block.

For \code{filterAdtQcMetrics}, a blocking factor should be provided if \code{block} was used to construct \code{thresholds}.}

\item{min.detected.drop}{Minimum drop in the number of detected features from the median, in order to consider a cell to be of low quality.}

\item{num.mads}{Number of median from the median, to define the threshold for outliers in each metric.}

\item{thresholds}{List with the same structure as produced by \code{suggestAdtQcThresholds}.}
}
\value{
For \code{computeAdtQcMetrics}, a list is returned containing:
\itemize{
\item \code{sum}, a numeric vector containing the total ADT count for each cell.
\item \code{detected}, an integer vector containing the number of detected tags per cell.
\item \code{subsets}, a list of numeric vectors containing the total count of each control subset. 
}
Each vector is of length equal to the number of cells.

For \code{suggestAdtQcThresholds} with \code{block!=NULL}, a list is returned containing:
\itemize{
\item \code{detected}, a numeric vector containing the lower bound on the number of detected tags for each blocking level.
\item \code{subsets}, a list of numeric vectors containing the upper bound on the sum of counts in each control subset for each blocking level.
}
Each vector is of length equal to the number of levels in \code{block}.

For \code{suggestAdtQcThresholds} with \code{block=NULL}, a list is returned containing:
\itemize{
\item \code{detected}, a numeric scalar containing the lower bound on the number of detected tags. 
\item \code{subsets}, a numeric vector containing the upper bound on the sum of counts in each control subset. 
}

For \code{filterAdtQcMetrics}, a logical scalar is returned indicating which cells are of high quality.
}
\description{
Compute per-cell QC metrics from an initialized matrix of ADT counts,
and use the metrics to suggest filter thresholds to retain high-quality cells.
}
\examples{
# Mocking a matrix:
library(Matrix)
x <- round(abs(rsparsematrix(1000, 100, 0.1) * 100))

# Mocking up a control set.
sub <- list(IgG=rbinom(nrow(x), 1, 0.1) > 0)

qc <- computeAdtQcMetrics(x, sub)
str(qc)

filt <- suggestAdtQcThresholds(qc)
str(filt)

keep <- filterAdtQcMetrics(filt, qc)
summary(keep)

}
\seealso{
\url{https://libscran.github.io/scran_qc/}, for the rationale of QC filtering on ADT counts.
}
\author{
Aaron Lun
}
